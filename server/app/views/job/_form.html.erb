<p>Use <code>{P}</code> as a payload marker</p>

<%= form_for(@job, :html => {class: 'create-form'}) do |f| %>
<div class="row">
  <div class="col-md-7">
    <label for="uri">Target</label><br>
        <%= f.select("http_method", options_for_select([['GET', 'GET'], ['POST', 'POST'], ["PUT", "PUT"], ["PATCH", "PATCH"], ["DELETE", "DELETE"]], @job.http_method), {}, {:class => 'inline' }) %>
        <%= f.text_field :http_uri, {:class => 'inline input-field fixed-length-text' } %><br>

    <label for="description">Job Description</label>
    <%= f.text_area :description, {:class => 'input-field input-field-full', :size => '50x6'} %>

    <label for="header">HTTP Headers</label>
    <%= f.text_area :http_headers, {:class => 'input-field input-field-full', :size => '50x6'} %>

    <label for="data">HTTP Post Data</label>
    <%= f.text_area :http_data, {:class => 'input-field input-field-full', :size => '50x6'} %>
    </div>

    <div class="col-md-5">  

    <label for="status">Job Status</label>
    <%= f.select(:status, options_for_select([['Start', 'active'], ['Pending', 'pending']], @job.status)) %>  
        <label for="node_limit">Node Allocation Limit (0 for no limit)</label><br />
        <em>Specify how many nodes can be allocated for this job</em>
        <%= f.text_field :node_limit, {:class => 'input-field' } %><br><br>

        <label for="type">Attack Type</label><br>
        <em>Specify the type of attack. For Denial-of-Service testing use repeat with no response matches</em>
        <%= f.select(:attack_type, options_for_select([['Repeat', 'repeat'], ['Dictionary', 'dictionary'], ['Brute Force', 'bruteforce']], @job.attack_type)) %>

        <div id="dictionary" <%= @job.attack_type != "dictionary" ? "class=hidden" : "" %>>
          <label for="dictionary">Dictionary</label>
          <%=
          select("job", "dictionary_id", @dictionaries.all.collect {|d| [ d.original_filename, d.id ] }, {prompt: 'Select Dictionary'})
          %>
        </div>
        <div id="charset" <%= @job.attack_type != "bruteforce" ? "class=hidden" : "" %>>
          <label for="charset">Character Set</label>
          <%= f.text_field :charset, {:class => 'input-field'} %>
        </div>

        <label for="response">Response Storage?</label><br>
        <em>Do you want the nodes to store every HTTP response? (Warning: Slow)</em>
        <%= f.select(:attack_mode, options_for_select([['None', 'none'], ['Store Full', 'store']], @job.attack_mode)) %><br><br>

    <label for="response">Response Matching</label><br>
    <em>Define flags to search for in HTTP responses. Useful for matching certain conditions. Supports string and regular-expression based matching. Can delivery matches instantly or in bulk</em>
    <fieldset id="response_flags">
    <% @job.response_flag_meta.each do |rfm| %>
      <input type="hidden" name="job[response_flag_meta][<%= rfm.id %>][id]" value="<%= rfm.id %>">
      <input class="input-field inline" type="text" name="job[response_flag_meta][<%= rfm.id %>][match_value]" value="<%= rfm.match_value %>" class="inline">

      <select name="job[response_flag_meta][<%= rfm.id %>][match_type]" class="inline">
        <option value="string" <%= "SELECTED" if rfm.match_type == "string" %>>String</option>
        <option value="regex" <%= "SELECTED" if rfm.match_type == "regex" %>>Regex</option>
      </select>

      <select name="job[response_flag_meta][<%= rfm.id %>][match_delivery]" class="inline">
        <option value="instant" <%= "SELECTED" if rfm.match_delivery == "instant" %>>Instant Delivery</option>
        <option value="batch" <%= "SELECTED" if rfm.match_delivery == "batch" %>>Batched Delivery</option>
      </select>
      <br />
    <% end %>
    </fieldset>

    <input type="button" id="addNewFlag" value="Add Flag"><br><br>
    </div>
    </div>

    <div class="row text-center button-inline">
      <%= submit_tag "Submit", class: 'button-primary inline' %>
      <%= button_to "Cancel", jobs_path, class: 'button-alternative inline' %>
    </div>
  <% end %>